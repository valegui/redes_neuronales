import random
import operator
import AST


class GeneticAlgorithm:
    """
    GeneticAlgorithm class
    """
    def __init__(self, population_size, fitness_fun, gene_generator,
                 termination_cond, max_iter, elitism=0.1, mutation_rate=0.9,
                 max_depth=10, initial_max_depth=6, seed=None):
        """
        Genetic Algorithm class constructor
        :param population_size: int. Number of individuals in the population.
        :param fitness_fun: function. Function that receives an individual an return its fitness.
        :param gene_generator: function. Function that generates an individual.
        :param termination_cond: function. Function that receives the fitness values of the generation
            and returns the index of the best individual if the fitness matches the "termination" criteria,
            or None if there must be another generation.
        :param max_iter: int. Number of max. iterations/generations.
        :param elitism: float. Percentage of elite individuals.
        :param mutation_rate: float. Percentage of the population to mutate. Must be leq to 1 - elitism.
        :param max_depth: int. Max depth of the sub-tree to generate.
        :param initial_max_depth: int. Max depth of a tree in the initial population.
        :param seed: int or None. Seed for random.
        """
        self.population_size = population_size
        self.fitness_fun = fitness_fun
        self.gene_generator = gene_generator
        self.termination_cond = termination_cond
        self.max_iter = max_iter
        self.elitism = elitism
        self.mutation_rate = mutation_rate
        self.max_depth = max_depth
        self.initial_max_depth = initial_max_depth
        # Placeholders for the population and its fitness values
        self.population = []
        self.fitness_values = []
        # For analysis
        self.best_fitness = []
        self.avg_fitness = []
        self.worst_fitness = []
        if seed is not None:
            random.seed(seed)
        assert 1 - self.elitism >= self.mutation_rate, "Mutation rate must be leq to 1 - elitism"

    def run(self):
        """
        Run the genetic algorithm for 'max_iter' iterations.
        If a certain individual meets the termination condition, the algorithm stops before those iterations.
        :return: The individual with best fitness
                 The number of iterations completed when the algorithm stopped
        """
        elites = int(self.elitism * self.population_size)
        mutated = int(self.mutation_rate * self.population_size)
        self.init_population()
        for i in range(self.max_iter):
            self.evaluate_fitness()
            self.add_to_analysis()  # For analysis
            terminated = self.termination_cond(self.fitness_values)
            if terminated is not None:
                return self.population[terminated], i + 1
            elite_individuals = self.select_elites(elites)  # Select elite individuals
            parents = self.select_mating_pool((self.population_size - elites) * 2)  # Selection of parents
            offspring_crossover = self.crossover(parents)  # Crossover of parents to get offspring
            offspring_mutation = self.mutation(offspring_crossover, mutated)  # Mutation of the offspring
            self.population = elite_individuals + offspring_mutation  # The population with elites and new individuals
        self.evaluate_fitness()
        return self.population[self.fitness_values.index(max(self.fitness_values))], self.max_iter

    def init_population(self):
        """
        Creates the population of the size 'population_size', in which each individual is generated by
        the 'gene_generator' function.
        :return:
        """
        for i in range(self.population_size):
            self.population.append(self.gene_generator(self.initial_max_depth))
        assert len(self.population) == self.population_size

    def evaluate_fitness(self):
        """
        Computes the fitness function for each individual of the population.
        :return:
        """
        self.fitness_values = []
        for p in self.population:
            self.fitness_values.append(self.fitness_fun(p))
        assert len(self.fitness_values) == self.population_size

    def select_mating_pool(self, number_of_parents):
        """
        Creates a mating pool two times the size of the expected offspring
        :return: Array with parents for the next generation
        """
        mating_pool = []
        for i in range(number_of_parents):  # Append parents
            mating_pool.append(self.select_parent())
        assert len(mating_pool) == 2 * (self.population_size - int(self.population_size * self.elitism))
        return mating_pool

    def select_parent(self):
        """
        Selects an individual of the population to be a parent with the tournament selection algorithm.
        :return: An individual of the population. The one that won the tourney.
        """
        k = 5
        parents = random.sample(range(self.population_size), k)  # Gets k random index of individuals
        best = parents[0]
        for i in parents:
            if self.fitness_values[i] > self.fitness_values[best]:  # Saves the index if the fitness is better
                best = i
        return self.population[best]  # Returns the best individual between the k selected

    def crossover(self, parents):
        """
        Given a set of parents, every two of them, selects a crossover point in a parent tree and replaces it with
        a sub-tree of the other parent tree.
        :param parents: Array with individuals that will generate the offspring.
        :return: Offspring, the array that will be the next population.
        """
        expected_offsprings = self.population_size - int(self.population_size * self.elitism)
        assert len(parents) == 2 * expected_offsprings
        offspring = []
        for i in range(expected_offsprings):
            parent_1 = parents.pop()
            parent_2 = parents.pop()
            new_element = parent_1.copy()  # Copies the first parent
            p1 = random.choice(new_element.serialize())  # Selects a crossover point in that copy
            p2 = random.choice(parent_2.serialize()).copy()  # Selects and copy a sub-tree in the second parent
            p1.replace(p2)  # Replaces the copy of the second parent in the point selected in the first one
            offspring.append(new_element)
        assert len(offspring) == expected_offsprings
        return offspring

    def mutation(self, offspring, number):
        """
        Given an offspring array, mutates a certain number of random individuals.
        :param offspring: Array of individuals.
        :param number: int. Number of individuals to mutate.
        :return: Offspring with mutated genes.
        """
        assert number <= len(offspring)
        idx = random.sample(range(len(offspring)), number)
        for i in idx:  # For each individual (selected) in the offspring
            rc = random.choice(offspring[i].serialize())  # Select a random sub-tree...
            rc.replace(self.gene_generator(self.max_depth))  # ...and replace it with a randomly generated sub-tree
        return offspring

    def get_analysis(self):
        """
        Return the values of the best fitness, the average fitness and the worst fitness per generation.
        Each return value is an array.
        :return: Best fitness array, average fitness array, worst fitness array
        """
        return self.best_fitness, self.avg_fitness, self.worst_fitness

    def add_to_analysis(self):
        """
        Add values of best fitness, average fitness and worst fitness to the corresponding array.
        :return:
        """
        self.best_fitness.append(max(self.fitness_values))
        self.avg_fitness.append(sum(self.fitness_values) / len(self.fitness_values))
        self.worst_fitness.append(min(self.fitness_values))

    def select_elites(self, number):
        """
        Select the N best individuals, according to their fitness value.
        source: https://stackoverflow.com/questions/50477976/location-of-n-max-values-in-a-python-list
        :param number: int. Number of individuals to be the E L I T E
        :return: Array of elite individuals.
        """
        d = {index: fit for index, fit in enumerate(self.fitness_values)}
        sorted_d = sorted(d.items(), key=operator.itemgetter(1), reverse=True)
        return [self.population[k[0]] for k in sorted_d][:number]